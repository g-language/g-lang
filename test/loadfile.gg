#include <stdio> as io
#include <stdlib> as lib

#define MEMFILE_FOPEN_ERROR    1
#define MEMFILE_ALLOC_ERROR    2
#define MEMFILE_SIZE_WARN      3

typedef struct Memfile
	union
		void* ptr;
		char* str;
		
	size size;
	const char* filename;
	
	void* alloc(size size);
	bool loadFile(const char* filePath, bool isStr = false );
	void free();
Memfile;

void* Memfile.alloc(size size)
	return .ptr = malloc(size);

bool Memfile.loadFile(const char* filename, bool isStr)
	File& file = io.fopen(filename, isStr ? "r" : "rb");
	int return = 0;
	size sz;
	
	strcpy(.filename, filename);
	
	if (!file)
		return MEMFILE_FOPEN_ERROR;
	
	.size = file.getSize();
	if (!.alloc(.size))
		return MEMFILE_ALLOC_ERROR;
	
	sz = file.read(.data, 1, .size);
	
	if (sz != .size)
		.size = sz;
		return = MEMFILE_SIZE_WARN;
	
	io.fclose(file);
	
	return return;

void Memfile.free()
	free(.data);
	free(.filename);
	memset(this, 0, sizeof(*this));

int main(int n, char** arg)
	Memfile mem = new();
	
	if (n != 2)
		lib.fprintf(lib.stderr, "Please provide an input file! %s <file>", arg[0]);
		return 1;
	
	switch (mem.loadFile("README.md", true))
		case MEMFILE_FOPEN_ERROR:
			lib.fprintf(lib.stdout, "Failed to fopen file [%s]", mem.filename);
			break;
		case MEMFILE_ALLOC_ERROR:
			lib.fprintf(lib.stdout, "Failed allocate Memfile");
			break;
		case MEMFILE_SIZE_ERROR:
			lib.fprintf(lib.stdout, "fread didn't match the expected size while loading file [%s]", mem.filename);
			break;
	
	mem.free();
	delete(mem);
	
	return 0;